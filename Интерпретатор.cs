/*
    Реализация примера из статьи "Матюхин. В. А. Подсчет значения арифметического выражения методом рекурсивного спуска"
    http://informatics.mccme.ru/mod/resource/view.php?id=19586 на языке C#.

    Интерпретатор способен вычислять выражения типа "(1 + 2 * 3) * (4 + 5) + 6 * (7 + 8) + 9".
    Доступны две математические операции: умножение и сложение. Умножение имеет приоритет над сложением.
    Скобки имеют самый высокий приоритет. Пробелы отбрасываются.
    Выполняется анализ корректности выражения.

    Синтаксис реализуемого языка, записанный в расширенной форме Бэкуса-Наура
    http://standards.iso.org/ittf/PubliclyAvailableStandards/s026153_ISO_IEC_14977_1996(E).zip :

    (* Терминалы, то есть базовые кирпичики. *)
    Цифра = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

    (* Число состоит из одной или более цифр. *)
    Число = Цифра, { Цифра } ;

    (* Так как сложение имеет минимальный приоритет, оно должно выполняться в последнюю очередь.
       То есть в итоге выражение должно быть представлено в виде суммы каких-то вычисленных значений.
       Пример с приоритетами: http://www.astorehouseofknowledge.info/w/Extended_Backus-Naur_Form *)
    Выражение = Слагаемое, { "+", Слагаемое } ;

    (* Умножение имеет более высокий приоритет. Значит слагаемое - это произведение каких-то множителей. *)
    Слагаемое = Множитель, { "*", Множитель } ;

    (* Скобки имеют самый высокий приоритет. Сперва вычисляются выражения в скобках. *)
    Множитель = Число | "(", Выражение, ")" ;

    См. также книгу "Молчанов А. Ю. Системное программное обеспечение - 2010".
*/

using System;
using System.Text;

class Интерпретатор
{
    private enum Лексема
    {
        Число,
        Плюс,
        Умножить,
        ОткрывающаяСкобка,
        ЗакрывающаяСкобка,
        Конец
    }

    // Вычисляемое выражение. Значение устанавливается в функции Вычислить(). 
    private string исходник;

    // Позиция в исходнике. Индекс символа, который будет проанализирован на очередном шаге.
    // Позиция сбрасывается в ноль в функции Вычислить().
    private int смещение;

    // Текущая лексема. Значение устанавливается при вызове функции СледующаяЛексема().
    private Лексема лексема;

    // Если текущая лексема - число, то нужно знать, что это за число.
    private uint число;

    // Вычисляет выражение, заданное в виде строки.
    public uint Вычислить(string исходник)
    {
        this.исходник = исходник;
        this.смещение = 0;

        // Ищем первую лексему.
        СледующаяЛексема();
        
        // Исходник пуст.
        if (лексема == Лексема.Конец)
            return 0;

        // Вычисляем выражение.
        uint результат = Выражение();

        // Последняя лексема должна быть Конец.
        if (лексема != Лексема.Конец)
            throw new Exception("Неожиданный конец исходника.");

        return результат;
    }

    // Устанавливает значение для переменной "лексема".
    private void СледующаяЛексема()
    {
        // Пропускаем пробелы.
        for (; смещение < исходник.Length; смещение++)
        {
            if (исходник[смещение] != ' ')
                break;
        }

        // Достигли конца исходника.
        if (смещение == исходник.Length)
        {
            лексема = Лексема.Конец;
            return;
        }

        // Находимся в начале лексемы. Выясняем, что это за лексема.
        // Заодно сразу же перемещаем курсор на следующий символ.
        char символ = исходник[смещение++];

        if (символ == '(')
        {
            лексема = Лексема.ОткрывающаяСкобка;
            return;
        }
        else if (символ == ')')
        {
            лексема = Лексема.ЗакрывающаяСкобка;
            return;
        }
        else if (символ == '*')
        {
            лексема = Лексема.Умножить;
            return;
        }
        else if (символ == '+')
        {
            лексема = Лексема.Плюс;
            return;
        }

        // Остался последний вариант: лексема - это число, состоящее  из одной или нескольких цифр.
        if (!char.IsDigit(символ))
            throw new Exception("Неожиданный символ.");

        лексема = Лексема.Число;

        // Собираем все цифры числа.
        StringBuilder числоваяСтрока = new StringBuilder(10);
        числоваяСтрока.Append(символ);

        for (; смещение < исходник.Length; смещение++)
        {
            char очереднойСимвол = исходник[смещение];

            // Если встречаем не цифру, то значит началась новая лексема.
            if (!char.IsDigit(очереднойСимвол))
            {
                // Преобразуем накопленную числовую строку в число и завершаем функцию.
                число = uint.Parse(числоваяСтрока.ToString());
                return;
            }

            числоваяСтрока.Append(очереднойСимвол);
        }

        // Накопление цифр прекратилось, так как был достигнут конец исходника.
        число = uint.Parse(числоваяСтрока.ToString());
    }

    // Недолго думая, переписываем правила EBNF в виде функций.
    // Функции рекурсивно вызывают друг друга, а промежуточные результаты вложенных вычислений
    // хранятся в этих функциях.
    // Выражение = Слагаемое, { "+", Слагаемое } ;
    uint Выражение()
    {
        uint промежуточныйРезультат = Слагаемое();

        while (лексема == Лексема.Плюс)
        {
            СледующаяЛексема();
            промежуточныйРезультат += Слагаемое();
        }

        return промежуточныйРезультат;
    }

    // Слагаемое = Множитель, { "*", Множитель } ;
    uint Слагаемое()
    {
        uint промежуточныйРезультат = Множитель();

        while (лексема == Лексема.Умножить)
        {
            СледующаяЛексема();
            промежуточныйРезультат *= Множитель();
        }

        return промежуточныйРезультат;
    }

    // Множитель = Число | "(", Выражение, ")" ;
    uint Множитель()
    {
        if (лексема == Лексема.Число)
        {
            uint возвращаемоеЗначение = число;
            СледующаяЛексема();
            return возвращаемоеЗначение;
        }

        if (лексема == Лексема.ОткрывающаяСкобка)
        {
            СледующаяЛексема();
            uint возвращаемоеЗначение = Выражение();

            if (лексема == Лексема.ЗакрывающаяСкобка)
                СледующаяЛексема();
            else
                throw new Exception("Несоответствие открывающих и закрывающих скобок.");

            return возвращаемоеЗначение;
        }

        throw new Exception("Неожиданная лексема (ошибка в исходнике).");
    }
}
